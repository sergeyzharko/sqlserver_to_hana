const path = require('path');
const fs = require('fs');
var zipFolder = require('zip-folder');
const { promisify } = require('util');
const readDir = promisify(fs.readdir);
const readFile = promisify(fs.readFile);
const lstat = promisify(fs.lstat);

const inputFolder = process.argv[2] || path.join(__dirname, 'sap-hana-ddl');
const outputFolder = process.argv[3] || path.join(__dirname, 'src');
const zipFile = process.argv[4] || path.join(__dirname, 'src.zip');

//const directoryPath = path.join(__dirname, inputFolder); // источник

// function traverseDir(dir, first) { // рекурсивный перебор файлов
//     fs.readdir(dir, (err, files) => {
//         if (err) {
//             return console.log('Unable to scan directory: ' + err);
//         } 
//         files.forEach(file => {
//             let fullPath = path.join(dir, file);
//             fs.lstat(fullPath, (err, stats) => {
//                 if (err) {
//                     return console.log(err);
//                 }
//                 if (stats.isDirectory()) {
//                     traverseDir(fullPath);
//                 } else {
//                     console.log(fullPath);
//                     replace(fullPath);
//                 }
//             })
//         });
//     });
// }


async function traverseDir(dir, first) {
  // рекурсивный перебор файлов
  const files = await readDir(dir);
  try {
    await Promise.all(
      files.map(file =>
        (async () => {
          try {
            const fullPath = path.join(dir, file);
            const stats = await lstat(fullPath);
            if (stats.isDirectory()) {
              await traverseDir(fullPath);
            } else {
            //   console.log('\t', fullPath);
              let arr = fullPath.split('_');
              if (arr[arr.length-1] === 'table.sql') await replace(fullPath); // обрабатывать только файлы, оканчивающиеся на _table.sql
            }
          } catch (err) {
            return console.log(err);
          }
        })(),
      ),
    );
  } catch (err) {
    return console.log('\x1b[31m%s\x1b[0m', 'Unable to scan directory: ' + err);
  }
}



async function replace(file) {
    let data = await readFile(file, 'utf8');
        var parentDir = path.dirname(file).split(path.sep).pop(); // имя папки файла
        var subParentDir = path.dirname(file).split(path.sep)[path.dirname(file).split(path.sep).length - 2]; // имя папки файла
        var result = data
        
            .replace(/\r/g, "") // перевести систему пробелов из CRLF в LF
            .replace(/(\/\*).*(\*\/)/g, '') // комментарий
            .replace(/(CREATE TABLE.*\"\(\n  )(\"[^\;]*\;)(\n\nALTER.+\;)/g, '$1key $2')
                // costraints:
                // CREATE TABLE - любые символы - "(\n  
                // " - любые символы кроме ; - ;\nALTER
     
            .replace(/(\s\s.*[^\,\(\t\s]$)/gm, '$1;') // добавить ; в конце последней строки (нет , ()
            //.replace(/(\s\s.*)\,$/gm, '$1;') // добавить ; в конце каждоый строки
            .replace(/\n\)\;/g, `\n}\ntechnical configuration {\n\tcolumn store;\n};`)
            .replace(/CREATE TABLE/g, 'entity')
            .replace(/NOT NULL GENERATED BY DEFAULT AS IDENTITY/g, 'generated by default as identity(start with 1 increment by 1 no minvalue no maxvalue no cache no cycle)')
            .replace(/NOT NULL/g, 'not null')
            .replace(/ NULL/g, ' null')
            .replace(/(N)('.*')/g, '$2') // default N'@UNKNOWN'
            .replace(/DEFAULT/g, 'default')
            .replace(/AS COALESCE/g, '= COALESCE')
            .replace(/null default\s([\w\.]+)/g, 'null default \'$1\'') // добавить кавычки
            .replace(/\'current_timestamp\'/ig, 'current_timestamp') // убрать кавчки

            .replace(/SMALLINT/g, ': Integer')
            .replace(/NVARCHAR\(/g, ': String(')
            .replace(/VARCHAR\(/g, ': String(')
            .replace(/NCHAR\(/g, ': String(')
            .replace(/BIGINT/g, ': Integer')
            .replace(/TINYINT/g, ': Integer')
            .replace(/INTEGER/g, ': Integer')
            .replace(/INT/g, ': Integer')
            .replace(/REAL/g, ': Decimal(24,6)')
            .replace(/FLOAT/g, ': Decimal(24,6)')
            .replace(/NUMERIC/g, ': Decimal')
            .replace(/DECIMAL/g, ': Decimal')
            .replace(/ TIMESTAMP/g, ' : UTCTimestamp')
            .replace(/VARBINARY/g, ': Binary(100)')
            .replace(/BINARY/g, ': Binary(100)')
            .replace(/TEXT/g, ': LargeString')
            .replace(/DATE/g, ': LocalDate')
            
            .replace(/\"\s?\(/g, '"{') // скобка после названия таблицы
            .replace(/\/\*w*\*\//g, '') // убрать комментарии
            .replace(/\,$/gm, ';') // ; в конце каждоый строки вместо ,
            //.replace(/(\d+)\;(\d+)/g, '$1,$2') // ; между двумя числами;
            .replace(/^/gm, "\t") // добавить табуляцию в начало строки
            .replace(/\n\t\n\t\n/gm, '\n\n') // лишние пустые строки
            .replace(/(\w+\:\:\w+\.)(\w+)/g, '$2'); // название таблицы

            // result = 'namespace sap_hana_ddl.' + ' {\n' + result + '\n\n};';
           result = `namespace sap_hana_ddl.${subParentDir};\n\ncontext ${parentDir} {\n${result}\n\n};`;
        // result = 'namespace sap_hana_ddl.' + subParentDir + ';\n\ncontext ' + parentDir + ' {\n' + result + '\n\n};';
        // добавление кода в начало и конец файла

        if (!fs.existsSync(outputFolder)) { fs.mkdirSync(outputFolder) }

        let newFolder = path.join(outputFolder, subParentDir);
        if (!fs.existsSync(newFolder)) { fs.mkdirSync(path.join(newFolder)) };

        let newName = path.join(newFolder, path.dirname(file).split(path.sep).pop() + '.hdbcds');
        console.log('\t', newName);
        fs.writeFileSync(newName, result, 'utf8');

}

function zipping(){
    zipFolder(outputFolder, zipFile, function(err) {
        if(err) {
            console.log('\x1b[31m%s\x1b[0m', 'Zipping error', err);
        } else {
            console.log('\x1b[32m%s\x1b[0m', 'Zipped');
        }
    });
}

var deleteFolderRecursive = outputPath => {
    if (fs.existsSync(outputPath)) {
      fs.readdirSync(outputPath).forEach(function(file, index){
        var curPath = path.join(outputPath, file);
        if (fs.lstatSync(curPath).isDirectory()) { // recurse
          deleteFolderRecursive(curPath);
        } else { // delete file
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(outputPath);
    }
    if (fs.existsSync(zipFile)) {fs.unlinkSync(zipFile)};
  };

// traverseDir(directoryPath, true);

deleteFolderRecursive(outputFolder);
traverseDir(inputFolder)
  .then(() => zipping())
  .catch(err => console.trace(err));

//setTimeout(zipping, 2000);