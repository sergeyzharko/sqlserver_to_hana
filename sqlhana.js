const path = require('path'),
    fs = require('fs'),
    zipFolder = require('zip-folder'),
    { promisify } = require('util'),
    readDir = promisify(fs.readdir),
    readFile = promisify(fs.readFile),
    lstat = promisify(fs.lstat),

    inputFolder = process.argv[2] || path.join(__dirname, 'sap-hana-ddl');
    outputFolder = process.argv[3] || path.join(__dirname, 'src');
    zipFile = process.argv[4] || path.join(__dirname, 'src.zip');

async function traverseDir(dir, first) {
  // рекурсивный перебор файлов
  const files = await readDir(dir);
  try {
    await Promise.all(
      files.map(file =>
        (async () => {
          try {
            const fullPath = path.join(dir, file);
            const stats = await lstat(fullPath);
            if (stats.isDirectory()) {
              await traverseDir(fullPath);
            } else {
            //   console.log('\t', fullPath);
              let arr = fullPath.split('_');
              if (arr[arr.length-1] === 'table.sql') await replace(fullPath); // обрабатывать только файлы, оканчивающиеся на _table.sql
            }
          } catch (err) {
            return console.log(err);
          }
        })(),
      ),
    );
  } catch (err) {
    return console.log('\x1b[31m%s\x1b[0m', 'Unable to scan directory: ' + err);
  }
}

async function replace(file) {
    let data = await readFile(file, 'utf8');
        // var parentDir = path.dirname(file).split(path.sep).pop(); // имя папки файла
        let createString = data.search(/CREATE TABLE \"\w+\:\:/);
        let lastChar = data.indexOf('::');
        let entity = data.slice(createString+14, lastChar)
        // var parentDir = data.search(/CREATE TABLE \"\w+\:\:/); // namespace from DDL
        // var subParentDir = path.dirname(file).split(path.sep)[path.dirname(file).split(path.sep).length - 2]; // имя папки файла
        let fileName = path.dirname(file).split(path.sep).pop();
        data = data
        
            .replace(/\r/g, "") // перевести систему пробелов из CRLF в LF
            .replace(/(\/\*).*(\*\/)/g, ''); // удалить комментарии

        data = constraints(data);

        data = data
            .replace(/(\s\s.*[^\,\(\t\s]$)/gm, '$1;') // добавить ; в конце последней строки (нет , ()
            //.replace(/(\s\s.*)\,$/gm, '$1;') // добавить ; в конце каждоый строки
            .replace(/\n\)\;/g, `\n}\ntechnical configuration {\n\tcolumn store;\n};`)
            .replace(/CREATE TABLE/g, 'entity')
            .replace(/NOT NULL GENERATED BY DEFAULT AS IDENTITY/g, 'generated by default as identity(start with 1 increment by 1 no minvalue no maxvalue no cache no cycle)')
            .replace(/NOT NULL/g, 'not null')
            .replace(/ NULL/g, ' null')
            .replace(/(N)('.*')/g, '$2') // default N'@UNKNOWN'
            .replace(/DEFAULT/g, 'default')
            .replace(/AS COALESCE/g, ': Integer = COALESCE')
            .replace(/null default\s([\w\.]+)/g, 'null default \'$1\'') // добавить кавычки
            .replace(/\'current_timestamp\'/ig, 'current_timestamp') // убрать кавчки

            .replace(/SMALLINT/g, ': Integer')
            .replace(/NVARCHAR\(/g, ': String(')
            .replace(/VARCHAR\(/g, ': String(')
            .replace(/NCHAR\(/g, ': String(')
            .replace(/BIGINT/g, ': Integer')
            .replace(/TINYINT/g, ': Integer')
            .replace(/INTEGER/g, ': Integer')
            .replace(/\sINT/g, ' : Integer')
            .replace(/REAL/g, ': Decimal(24,6)')
            .replace(/FLOAT/g, ': Decimal(24,6)')
            .replace(/NUMERIC/g, ': Decimal')
            .replace(/DECIMAL/g, ': Decimal')
            .replace(/ TIMESTAMP/g, ' : UTCTimestamp')
            .replace(/VARBINARY/g, ': Binary(100)')
            .replace(/BINARY/g, ': Binary(100)')
            .replace(/TEXT/g, ': LargeString')
            .replace(/DATE/g, ': LocalDate')
            
            .replace(/\"\s?\(/g, '"{') // скобка после названия таблицы
            .replace(/\/\*w*\*\//g, '') // убрать комментарии
            .replace(/\,$/gm, ';') // ; в конце каждоый строки вместо ,
            //.replace(/(\d+)\;(\d+)/g, '$1,$2') // ; между двумя числами;
            .replace(/^/gm, "\t") // добавить табуляцию в начало строки
            .replace(/\n\t\n\t\n/gm, '\n\n') // лишние пустые строки
            .replace(/(\w+\:\:\w+\.)(\w+)/g, '$2'); // название таблицы

           data = `namespace ${entity};\n\ncontext ${fileName} {\n${data}\n\n};`;
        // добавление кода в начало и конец файла

        if (!fs.existsSync(outputFolder)) { fs.mkdirSync(outputFolder) }

        let newFolder = path.join(outputFolder, entity);
        if (!fs.existsSync(newFolder)) { fs.mkdirSync(path.join(newFolder)) };

        let newName = path.join(newFolder, fileName + '.hdbcds');
        console.log('\t', newName);
        fs.writeFileSync(newName, data, 'utf8');

}

let zipping = () => {
    zipFolder(outputFolder, zipFile, function(err) {
        if(err) {
            console.log('\x1b[31m%s\x1b[0m', 'Zipping error', err);
        } else {
            console.log('\x1b[32m%s\x1b[0m', 'Zipped');
        }
    })
};

let deleteFolderRecursive = outputPath => {
    if (fs.existsSync(outputPath)) {
      fs.readdirSync(outputPath).forEach(function(file, index){
        var curPath = path.join(outputPath, file);
        if (fs.lstatSync(curPath).isDirectory()) { // recurse
          deleteFolderRecursive(curPath);
        } else { // delete file
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(outputPath);
    }
    if (fs.existsSync(zipFile)) {fs.unlinkSync(zipFile)};
};

let constraints = file => {

    arr = file.match(/ALTER TABLE .* PRIMARY KEY .*\)\;/g) || []; // поиск всех constraints на primary key
    file = file.replace(/(ALTER.+)\;/g, '// $1'); // закомментировать все constrains
    if (!arr.length) {return file};

    let b = [];

    arr.forEach((value, index) => {
        b[index] = {};
        b[index].tableName = value.replace(/ALTER TABLE \"(.+)\" ADD .*/g, '$1');
        b[index].fields = JSON.parse('[' + value.replace(/.*\((\".+\")\).*/g, '$1') + ']');
    });

    b.forEach((value) => {
        let table = value.tableName.replace(/\:\:/, '\\:\\:');
        value.fields.forEach((field) => {
            var re = new RegExp('(CREATE TABLE \\"' + table + '\\"\\(\\n[^//]*  )(\\"'+ field +'\\")',"g");
            // (\\n[^//]*  ) - с новой строки. кроме комментариев, два пробела в начале строки
            file = file.replace(re, '$1key $2')
        });
    });

    return file;
}

// traverseDir(directoryPath, true);

deleteFolderRecursive(outputFolder);
traverseDir(inputFolder)
  .then(() => zipping())
  .catch(err => console.trace(err));

//setTimeout(zipping, 2000);